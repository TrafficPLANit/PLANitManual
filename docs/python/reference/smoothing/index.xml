<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>PLANit â€“ Smoothing</title>
    <link>https://planitmanual.github.io/version/0_1_0/docs/python/reference/smoothing/</link>
    <description>Recent content in Smoothing on PLANit</description>
    <generator>Hugo -- gohugo.io</generator>
    
	  <atom:link href="https://planitmanual.github.io/version/0_1_0/docs/python/reference/smoothing/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Docs: MSA</title>
      <link>https://planitmanual.github.io/version/0_1_0/docs/python/reference/smoothing/msa/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://planitmanual.github.io/version/0_1_0/docs/python/reference/smoothing/msa/</guid>
      <description>
        
        
        &lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;
&lt;p&gt;The Method of successive averages is a very basic, yet powerful smoothing method. In this method, every iteration is weighed equally in the final result which is achieved by applying the following function to the data that is being smoothed (can be flow, can be cost, can be something else, this depends on the assignment method that is adopted).&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(\Large x_{i+1}=(1-s_i) \cdot x_{i} + s_i \cdot y \qquad \text{where } {s_i= {1 \over i} \qquad \text{with } i=1,...,I. }\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Explanatino of variables:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(i= \textrm{ iteration index given a total of } I \textrm{ iterations},\\ s_i= \textrm{ step size in iteration } i,\\ x_i= \textrm{ result of smoothed value in iteration } i,\\ y= \textrm{ new found value to update result},\\ \\\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;As can be seen, the more iterations are conducted, the less the newly found value is incorporated in the result. Therefore, using MSA guarantees convergence of &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; (although it does not guarantee convergemce of &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt;.&lt;/p&gt;
&lt;h4 id=&#34;defaults&#34;&gt;Defaults&lt;/h4&gt;
&lt;p&gt;This class has no defaults (yet)&lt;/p&gt;
&lt;h4 id=&#34;methods&#34;&gt;Methods&lt;/h4&gt;
&lt;p&gt;This class has no methods (yet)&lt;/p&gt;
&lt;h4 id=&#34;properties&#34;&gt;Properties&lt;/h4&gt;
&lt;p&gt;This class has no properties (yet)&lt;/p&gt;
&lt;h4 id=&#34;example-1&#34;&gt;Example 1&lt;/h4&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb1&#34;&gt;&lt;pre class=&#34;sourceCode python&#34;&gt;&lt;code class=&#34;sourceCode python&#34;&gt;&lt;span id=&#34;cb1-1&#34;&gt;&lt;a href=&#34;#cb1-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;im&#34;&gt;from&lt;/span&gt; planit &lt;span class=&#34;im&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;*&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-2&#34;&gt;&lt;a href=&#34;#cb1-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-3&#34;&gt;&lt;a href=&#34;#cb1-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;# choose to run PLANit with a traditional static traffic assignment method&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-4&#34;&gt;&lt;a href=&#34;#cb1-4&#34;&gt;&lt;/a&gt;planit_instance &lt;span class=&#34;op&#34;&gt;=&lt;/span&gt; PLANit()&lt;/span&gt;
&lt;span id=&#34;cb1-5&#34;&gt;&lt;a href=&#34;#cb1-5&#34;&gt;&lt;/a&gt;planit_instance.&lt;span class=&#34;bu&#34;&gt;set&lt;/span&gt;(TrafficAssignment.TRADITIONAL_STATIC)&lt;/span&gt;
&lt;span id=&#34;cb1-6&#34;&gt;&lt;a href=&#34;#cb1-6&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-7&#34;&gt;&lt;a href=&#34;#cb1-7&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;# set smoothing to MSA&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-8&#34;&gt;&lt;a href=&#34;#cb1-8&#34;&gt;&lt;/a&gt;planit_instance.assignment.&lt;span class=&#34;bu&#34;&gt;set&lt;/span&gt;(Smoothing.MSA)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&#34;see-also&#34;&gt;See also&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;../../assignment&#34;&gt;Traffic assignment&lt;/a&gt; on assignments that support this virtual cost implementation&lt;br /&gt;
&lt;a href=&#34;../../enums/smoothingtype&#34;&gt;Smoothing.&amp;lt;enum&amp;gt;&lt;/a&gt; for all available smoothing type options&lt;/p&gt;
&lt;h4 id=&#34;source-code&#34;&gt;Source code&lt;/h4&gt;
&lt;p&gt;Class &lt;code&gt;SmoothingWrapper&lt;/code&gt; in &lt;code&gt;Wrappers.py&lt;/code&gt;&lt;/p&gt;

      </description>
    </item>
    
  </channel>
</rss>
